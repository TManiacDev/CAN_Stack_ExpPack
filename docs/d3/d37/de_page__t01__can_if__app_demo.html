<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>STM32Cube Expansion Pack CAN Stack: Tutorial 01: CanIf_AppDemo</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">STM32Cube Expansion Pack CAN Stack
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('d3/d37/de_page__t01__can_if__app_demo.html','../../');});
/* @license-end */
</script>
<div id="doc-content">
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Tutorial 01: CanIf_AppDemo </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#de_secTut_01_open">Einleitung</a></li>
<li class="level1"><a href="#de_secDownload">Das STM32CubeIDE Expansion Package herunter laden</a></li>
<li class="level1"><a href="#de_secNewProject">Starten eines neuen Projektes</a><ul><li class="level2"><a href="#de_subsecMain_c">Kurzer Überblick über den Aufbau der main.c Datei</a></li>
</ul>
</li>
<li class="level1"><a href="#de_secPackIntegration">Wie kommt das Expansion Package in die STM32CubeIDE</a><ul><li class="level2"><a href="#de_subsecManagePack">Manage Software Packs</a></li>
<li class="level2"><a href="#de_subsecSelectComp">Auswahl der Module</a></li>
</ul>
</li>
<li class="level1"><a href="#secConfigPack">Konfiguration der Module</a><ul><li class="level2"><a href="#de_subsecHWsettings">Hardware Settings</a><ul><li class="level3"><a href="#autotoc_md2">Bitrate Generator</a></li>
<li class="level3"><a href="#autotoc_md3">bxCAN Master Setup / bxCAN Slave Setup</a></li>
</ul>
</li>
<li class="level2"><a href="#de_subsecCanInterface">CAN Interface</a><ul><li class="level3"><a href="#autotoc_md4">Parameter Settings</a></li>
<li class="level3"><a href="#autotoc_md5">RX/TX PDU Configuration</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#secFirstCodeGen">Den Code für das CanIf Modul generieren</a></li>
<li class="level1"><a href="#de_HALvsPACK">Das ExpansionPack übernimmt Aufgaben aus der HAL</a><ul><li class="level2"><a href="#autotoc_md12">Diese Punkte muss ich noch ins Tutorial aufnehmen</a></li>
</ul>
</li>
<li class="level1"><a href="#de_secRestartIDE">Was ist bei einem &quot;normalen&quot; Öffnen der IDE anders als beim ersten Start</a></li>
</ul>
</div>
<div class="textblock"><p>The English version is <a class="el" href="../../d0/d29/eng_page__t01__can_if__app_demo.html">here</a>.</p>
<h6></h6>
<h1><a class="anchor" id="de_secTut_01_open"></a>
Einleitung</h1>
<p>Dieses Tutorial beschreibt den grundsätzlichen Umgang mit dem ExpansionPack. Beginnend mit dem Aufsetzen eines neuen Projektes in der STM32CubeIDE über das Laden des Packs und dessen Konfiguration, sowie dem Empfang und dem Senden von einfachen CAN Messages. Die Tutorialbeschreibung ist sehr Bilder lastig, man muss also relativ viel scrollen. Ich denke aber, dass die Bilder jeden helfen sich zu Recht zu finden.</p>
<h6></h6>
<h1><a class="anchor" id="de_secDownload"></a>
Das STM32CubeIDE Expansion Package herunter laden</h1>
<p>Es macht Sinn das ExpansionPack vor Beginn zu downloaden. Wenn man sich im Repository bewegt, hat man das ExpansionPack schon vorliegen. Nun auch auf <a href="https://github.com/TManiacDev/CAN_Stack_ExpPack">github</a></p>
<h6></h6>
<h1><a class="anchor" id="de_secNewProject"></a>
Starten eines neuen Projektes</h1>
<p>Nach dem Start der STM32CubeIDE wird man nach dem <em>Workspace</em> gefragt in welchem man arbeiten möchte. Ich nutze für das gesamte Projekt um den <em>CAN Stack</em> durchgängig den Workspace wie im folgenden Bild. </p><div class="image">
<img src="../../T01_P00_select_workspace.png" alt="" width="500"/>
<div class="caption">
Select Workspace directory</div></div>
<p> Hierbei sei erwähnt, dass das "projects"-Verzeichnis eben auch jenem entspricht, welches als Spiegel zum Repository gepflegt wird.</p>
<p>Beim ersten Start der STM32CubeIDE wird man von dem "Information Center" begrüßt. Hier wählen wir natürlich für's Erste aus, dass wir ein neues Projekt starten möchten. </p><div class="image">
<img src="../../T01_P01_start_new_project.png" alt="" width="80%"/>
<div class="caption">
Start new STM32 project</div></div>
<p> Später wird dieses "Information Center"-Fenster nicht unmittelbar beim Start angezeigt. Ich werde am <a class="el" href="../../d3/d37/de_page__t01__can_if__app_demo.html#de_secRestartIDE">Ende des Tutorials</a> kurz auf den Neustart der STM32CubeIDE eingehen.</p>
<p>Ein STM32CubeIDE-Projekt (und auch ein STM32CubeMX-Projekt) baut natürlich auf einen bekannten STM32-Mikrocontroller auf. Ich habe ein Nucleo-F439ZI Board, auf welchen ich arbeite. Das NUCLEO-F439ZI hat, wie fast alle anderen NUCLEO-Boards auch, standardmäßig kein CAN. Man kommt aber über die "ARDUINO(R) UnoV3" Verbinder an die notwendigen Pins heran. So habe ich mir ein "Extension Board" mit zwei CAN Transceiver gebastelt. Wir werden später die verwendeten Port-Pins auswählen. </p><div class="image">
<img src="../../T01_P02_select_board.png" alt="" width="80%"/>
<div class="caption">
Select Board or MCU</div></div>
<p>Die folgenden Dialoge sollten selbst erklärend sein. Wichtig ist, dass das ExpansionPack in C++ geschrieben ist. Die Voreinstellung ist hier leider immer C. Die Auswahl des verwendeten STM32Cube Firmware Package spielt aktuell noch keine Rolle, also sollte das aktuellste verwendet werden. </p><div class="image">
<img src="../../T01_P03_create_project.png" alt="" width="80%"/>
<div class="caption">
Steps to create project</div></div>
<p> Das Initialisieren der gesamten MCU-Peripherie ist nicht unbedingt erforderlich. Da es aber auch die Takterzeugung beinhaltet, ist es in den meißten Fällen sinnvoll.</p>
<p>Mit "Open Associated Perspective" wird in der STM32CubeIDE (entsprechend der Eclipse Umgebung) immer die Ansicht geöffnet, welche eben für den Arbeitsschritt am besten geeignet oder evtl sogar erforderlich ist. Hier wird im folgenden die Perspective geöffnet, welche die Konfiguration mit grafischer Unterstützung ermöglicht. Die Perspective sieht wie folgt aus: </p><div class="image">
<img src="../../T01_P04_new_project.png" alt="" width="80%"/>
<div class="caption">
New project perspective</div></div>
<p>Ich möchte hier nicht explizit auf den Aufbau der STM32CubeIDE eingehen. Wichtig an dieser Stelle ist, das wir auf der linken Seite den "normalen" Eclipse Project Browser haben. Der Großteil der Arbeitsfläche wird von der Darstellung der "*.ioc"-Datei verwendet. Die Ansicht des Controllers ist auf den jeweilgen Footprint angepasst. Wie man auf dem Bild erkennen kann, hat der STM32F439ZIT auf meinem NUCLEO-F439ZI Board einen LQFP144 Footprint.</p>
<p>Die STM32CubeIDE benennt die neu erzeugte "*.ioc"-Datei genauso wie das Projekt. Demnach haben wir jetzt eine "CanIf_AppDemo.ioc".</p>
<p>Da wir den CAN-Controller verwenden wollen, müssen wir diesen auch konfigurieren. CAN stellt eine "Connectivity" Peripherie dar. Also finden wir unter diesem Punkt auch die Module "CAN1" und "CAN2". Bei meinem NUCLEO-F439ZI gibt es standardmäßig keine Vorbereitung für CAN, also sind diese Module deaktiviert. Wählt man "CAN1" (oder auch "CAN2") aus, so erscheint eine zusätzliche Spalte mit der Bezeichnung "CAN1 Mode and Configuration". Die Darstellung mit diesen drei Spalten ist jener Aufbau welcher für die Konfiguration der STM32Cube-Elemente (welche intern immer als Pack gehandhabt werden) verwendet wird.</p>
<p>Im Bereich "Mode" aktiviert man die jeweiligen Module. Wir aktivieren nun das CAN1 Module durch setzen des Hakens "Activated". </p><div class="image">
<img src="../../T01_P05_activate_can1.png" alt="" width="80%"/>
<div class="caption">
CAN1 activated</div></div>
<p>Jetzt werden im Bereich "Configuration" vier Tabs angezeigt. Der Tab "User Constants" spielt für uns keine Rolle. Dieser Tab wird in jeden Modul angezeigt. "Parameter Settings" beinhaltet die Startup Parameter des CAN-Controllers und NVIC Settings die Einstellung der verwendeten Interrupt-Callbacks. Das <em>ExpansionPack CAN Stack</em> übernimmt auch die Konfiguration der Startup Parameter, also lassen wir die "Parameter Settings" hier wie sie sind. Die Konfiguration der Interrupt-Callbacks werden wir später aufgreifen. </p><div class="image">
<img src="../../T01_P06_other_parameter.png" alt="" width="80%"/>
<div class="caption">
Parameter and NVIC Settings</div></div>
<p> Im Tab "GPIO Settings" werden die Port-Pins eingestellt, bzw angezeigt. Die Funktion der Pins lassen sich durch anklicken des Pins in der µC-Darstellung direkt auswählen. Bei meinem CAN-Transceiver-Board sind CAN1_RX an PB8 und CAN1_TX an PB9 angebunden. So nehme ich diese Einstellung hier auch vor. </p><div class="image">
<img src="../../T01_P07_select_pinout.png" alt="" width="80%"/>
<div class="caption">
GPIO Settings</div></div>
<p>Nun wird es Zeit die Konfiguration das erste Mal zu speichern. Beim Klick auf die "Diskette" speichert STM32CubeIDE (entsprechend der Eclipse-Umgebung) die jeweils aktive Datei. Da wir gerade die "CanIf_AppDemo.ioc" bearbeitet haben, wird diese gespeichert. Beim speichern einer "*.ioc-Datei" fragt die STM32CubeIDE standardmäßig ob der Source Code generiert werden soll. (Das sollte man später im Hinterkopf behalten, wenn man testweise Code ändert.) Danach wird man gefragt ob man zur C/C++ Perspective wechseln möchte. </p><div class="image">
<img src="../../T01_P08_first_save.png" alt="" width="80%"/>
<div class="caption">
Save CanIf_AppDemo.ioc and generate code</div></div>
<p>Der erzeugte Code sollte build-fähig sein. Das können wir durch den Klick auf den "Hammer" probieren </p><div class="image">
<img src="../../T01_P09_new_main_c.png" alt="" width="40%"/>
<div class="caption">
Build generated code</div></div>
<p>Im Project Browser sind nun auch die neuen Dateien sichtbar. Die C/C++ Perspective bietet uns eine "Outline"-Übersicht über die aktive Datei. Im unteren Bereich der IDE findet man weitere hilfreiche Fenster. Details sollte man sich selber in diversen Eclipse Tutorials erarbeiten.</p>
<h6></h6>
<h2><a class="anchor" id="de_subsecMain_c"></a>
Kurzer Überblick über den Aufbau der main.c Datei</h2>
<p>Ich möchte hier an Hand der <code>main.c</code> Datei ganz kurz auf ein paar Besonderheiten im Umgang mit der Code Generierung in der STM32CubeIDE eingehen. Vielleicht verschiebe ich das Kapitel mal und mache es etwas ausführlicher. Dann kann man auch Besonderheiten bei der Bearbeitung der <code>*</code>.ftl Templates eingehen.</p>
<div class="image">
<img src="../../T01_P10_basics_on_main_c_teil1.png" alt="" width="50%"/>
<div class="caption">
how to work on main.c</div></div>
<p> STM nutzt eine Doxygen taugliche Formatierung, so dass man auch die Lizenzinformationen in der Source Code Doku einbinden kann. Der Dateikopf ist in einem </p><pre class="fragment"> USER CODE BEGIN Header
 [...]
 USER CODE END Header
</pre><p>Block eingeordnet. Alles was in solch einem Block steht, wird bei einer erneuten Generierung nicht geändert. Diese Blöcke werden aber durch den Generator vorgegeben. Es macht also keinen Sinn selber solche Blöcke zu ergänzen. Man sieht hier zum Beispiel die "User Code" Blöcke für Includes und typedefs.</p>
<p>Es sei aber erwähnt, das der Code "verschwindet" wenn die Datei bei der Code Generation entfernt wird, zum Beispiel dann wenn man ein Modul deaktiviert.</p>
<div class="image">
<img src="../../T01_P10_basics_on_main_c_teil2.png" alt="" width="50%"/>
<div class="caption">
Handles to work with the hardware</div></div>
<p> STM nutzt "Handle"-Strukturen um mit der jeweiligen Peripherie (bis auf GPIO) zu arbeiten. Standardmäßig wird das Handle-Objekt im Kontext der <code>main.c</code> erzeugt. Dieses endhält neben dem Pointer zu den Registern auch eine Struktur zur Initialisierung.</p>
<div class="image">
<img src="../../T01_P10_basics_on_main_c_teil3.png" alt="" width="50%"/>
<div class="caption">
Function declerations</div></div>
<p> Diese <code>MX_</code>(HW-Module)_Init() Funktionen werden für jedes Modul generiert. Logisch werden diese Funktionen weiter unten dann mit den Parametern aus dem <code>*</code>.ioc File gefüttert.</p>
<p>Darüber hinaus haben wir hier auch Platz um eigene (einfache) Funktionen zu deklarieren ("User Code * PFP") und auch zu definieren ("User Code * 0"). Wie gesagt, was man in solch einen Block hinein schreibt, bleibt auch bei einer Re-Generation erhalten.</p>
<div class="image">
<img src="../../T01_P10_basics_on_main_c_teil4.png" alt="" width="50%"/>
<div class="caption">
main() Function</div></div>
<p> Die eigentliche <code>main()</code> Funktion ruft der Reihe nach die <code>Init()</code> -Funktionen auf und geht anschließend in die für Mikrocontroller typische <code>while(1)</code> Schleife.</p>
<p>Die Reihenfolge der <code>MX_</code>(HW-Module)_Init() Funktionen wird leider vom Code Generator vorgegeben. So lange man ausschließlich die HAL nutzt, spielt das keine Rolle. Da wir in unserem Expansion Pack aber HAL-Aufgaben übernehmen wollen, braucht es da einen gezielten Ansatz.</p>
<p>Nach der <code>main()</code> kommen dann die einzelnen <code>MX_</code>(HW-Module)_Init() Funktionen. Als Beispiel hier nur kurz <code>MX_CAN1_Init()</code> Funktionen </p><div class="image">
<img src="../../T01_P10_basics_on_main_c_teil5.png" alt="" width="50%"/>
<div class="caption">
Init the CAN1 Controller</div></div>
<p> Grundsätzlich wird nur die Init-Struktur gefüllt und dann die eigentliche <code>HAL_CAN_Init()</code> aufgerufen. Nur wo werden die Pins zu geordnet. Dazu komme ich dann wenn es so weit ist.</p>
<h6></h6>
<h1><a class="anchor" id="de_secPackIntegration"></a>
Wie kommt das Expansion Package in die STM32CubeIDE</h1>
<h2><a class="anchor" id="de_subsecManagePack"></a>
Manage Software Packs</h2>
<p>Nun wollen wir aber endlich das STM32Cube ExpansionPack zu unserem Projekt hinzufügen. Als erstes müssen wir der IDE sagen wo sie das ExpansionPack findet. </p><div class="image">
<img src="../../T01_P11_manage_software_packs.png" alt="" width="80%"/>
<div class="caption">
Open manage software packs dialog</div></div>
<p> Wir gehen also wieder in die Ansicht der <code>CanIf_AppDemo.ioc</code> Datei und wählen "Manage Software Packs".</p>
<div class="image">
<img src="../../T01_P12_load_pack.png" alt="" width="80%"/>
<div class="caption">
load pack</div></div>
<p> Man kann das ExpansionPack entweder lokal von der Festplatte oder per URL aus der Ferne integrieren. Wir hatten <a class="el" href="../../d3/d37/de_page__t01__can_if__app_demo.html#de_secDownload">am Anfang</a> das ExpansionPack herunter geladen (oder wir haben es parallel in einem Development-Verzeichnis). Dieses ExpansionPack suchen wir hier und wählen es aus.</p>
<div class="image">
<img src="../../T01_P13_accept_license.png" alt="" width="80%"/>
<div class="caption">
License agrement</div></div>
<p> Wenn wir dann die Lizenzbedingungen gelesen und akzeptiert haben, ist das ExpansionPack integriert.</p>
<p>Man findet hier in dem Fenster auch ein paar nützliche Informationen zum Umgang mit dem ExpansionPack. Da steht zum Beispiel etwas zu den MX-Funktionen.</p>
<h6></h6>
<h2><a class="anchor" id="de_subsecSelectComp"></a>
Auswahl der Module</h2>
<p>Jetzt müssen wir noch auswählen, welche Komponenten aus dem ExpansionPack genutzt werden sollen. </p><div class="image">
<img src="../../T01_P14_select_component.png" alt="" width="80%"/>
<div class="caption">
load pack</div></div>
<p> Es öffnet sich der "Software Pack Component Selector". Erst einmal ein kleines Bild. Ins Detail gehen wir gleich. </p><div class="image">
<img src="../../T01_P15_pack_selector.png" alt="" width="30%"/>
<div class="caption">
Software Pack Component Selector</div></div>
<p> Hier sind unter anderem alle von STMicroelectronics verfügbaren ExpansionPacks auswählbar. Klickt man auf <code>Install</code> wird das jeweilige ExpansionPack bei STM herunter geladen und installiert. Wir scrollen aber ein wenig nach unten und suchen <code>TM_Engineering.CAN_Stack</code>. </p><div class="image">
<img src="../../T01_P16_select_appdemo.png" alt="" width="80%"/>
<div class="caption">
Select the Demo Application</div></div>
<p> Durch Klick auf "&gt;" kann man die einzelnen Module, oder genauer gesagt die einzelnen Bundles öffnen. Naiv wählen wir die Demo Application <code>CanIf_AppDemo</code> (deswegen haben wir unser Projekt am Anfang auch so benannt) aus.</p>
<p>Nun werden da aber ein paar gelbe Warnschilder mit Ausrufezeichen angezeigt. </p><div class="image">
<img src="../../T01_P17_additional_info.png" alt="" width="80%"/>
<div class="caption">
Bundle warnings and Info</div></div>
<p> Klickt man auf den <img src="../../DetailsButton.png" alt="" class="inline" title="(i) button"/> Button (siehe beige/roter Pfeil) kann man ein paar Informationen zum jeweils aktiven Element bekommen. So steht zum Beispiel bei unserer Application: "This component has unresolved dependencies". Es braucht also noch irgend ein anderes Modul. Weiter steht da "There are solutions within this pack". Die Lösung des Problems liegt also nahe. <br  />
 Mit dem <img src="../../DependenciesButton.png" alt="" class="inline" title="chain button"/> Button (grün/roter Pfeil) dann kann man die Abhängigkeiten unmittelbar anzeigen. In unserem Fall braucht die <code>DemoApplication</code> eine Komponente <code>CanIf/Can</code> </p>
<p>Wir ergänzen also die noch notwendigen Module die sich alle im Bundle Board Support befinden.</p><ul>
<li>Dies kann man unter anderem in dem man direkt auf "Select" klickt.</li>
<li>Mit "Show" kann man die Lösung vor selektieren.</li>
<li>Und mit "Resolve" löst man alle verketteten Probleme mit einmal. Also in unserem Fall werden die drei erforderlichen Module ausgewählt.</li>
</ul>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Module  </th><th class="markdownTableHeadNone">Inhalt   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">general / Common  </td><td class="markdownTableBodyNone">Hier sind die Header Files mit den Compiler Abhängigkeiten oder auch eine Klasse zur Handhabung von Versionsinformationen zur Laufzeit enthalten   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="../../db/db1/class_com_if.html" title="the base class to hold a unique interface to all communication controller interface types">ComIf</a> / Common  </td><td class="markdownTableBodyNone">Darin ist eine virtuelle Klasse enthalten, welche zur Abstraktion von Kommunikation Interface Klassen ähnlich dem AUTOSAR Ansatz vorgesehen ist   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">bxCan_Master / Can  </td><td class="markdownTableBodyNone">Dies ist unsere abgeleitete Interface Klasse welche den Master des bxCAN Controllers darstellt   </td></tr>
</table>
<div class="image">
<img src="../../T01_P18_select_modules.png" alt="" width="80%"/>
<div class="caption">
Select needed modules</div></div>
<p>Haben wir diese drei Module aktiv, werden wir mit grünen Häkchen belohnt und können den Selector wieder schließen.</p>
<h6></h6>
<h1><a class="anchor" id="secConfigPack"></a>
Konfiguration der Module</h1>
<p>Das Aktivieren der Module erfolgt auf dem gleichen Weg, wie wir zu Beginn das CAN-Modul aktiviert haben. In der linken Spalte des <code>CanIf_AppDemo.ioc</code> Viewers findet man jetzt einen weiteren Punkt "Software Packs". Unter diesen Punkt werden alle aktiven ExpansionPacks aufgeführt. Aktuell haben wir nur ein Pack, also ist hier auch nur unser <code>TM_Engineering.CAN_Stack</code> zu finden. Aktiviert man das Module "Board Support CanIf" erhält man im Configuration Abschnitt die Tabs "Hardware Settings", "CAN Interface" und "User Constants". Der Tab "User Constants" ist der gleiche den wir schon aus den Einstellungen des CAN-Modules kennen.</p>
<h2><a class="anchor" id="de_subsecHWsettings"></a>
Hardware Settings</h2>
<p>Die Hardware Settings sind jene, welche durch das CanIf-Module kontrolliert werden. In der AUTOSAR Spec werden diese Parameter durch das CAN-Modul bearbeitet. Wir müssen dies über die STM-HAL erledigen. </p><div class="image">
<img src="../../T01_P19_config_modules.png" alt="" width="80%"/>
<div class="caption">
Config the Hardware Settings of the CanIf module</div></div>
<p> Auch in dem "Configuration" Abschnitt gibt es wieder einen (i) Button um mehr über die einzelnen Parameter zu erfahren.</p>
<h3><a class="anchor" id="autotoc_md2"></a>
Bitrate Generator</h3>
<p>Mit diese Parameter werden durch den Source Code Generator die notwendigen Hardware Parameter berechnet um die jeweiligen Baudraten zu erzeugen. Neben diesen Parametern wird die Clock des CAN Modules aus den Systemparametern genutzt. </p><dl class="section remark"><dt>Remarks</dt><dd>Aktuell existiert kein Support für System Clock Switch während der Laufzeit!!!</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Parameter  </th><th class="markdownTableHeadNone">Beschreibung   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">List of Bitrates  </td><td class="markdownTableBodyNone">Hier wird die Liste der gewünschten Bitraten angelegt. Die einzelnen Bitraten werden durch Kommas getrennt.<br  />
Die hier gewählten Baudraten sind während der Laufzeit auswählbar.<br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Bittiming Sample Point  </td><td class="markdownTableBodyNone">Sample Point als Prozent oder Kommazahl. Der Sample Point muss entweder größer 50% oder eben 0.5 &lt; x &lt; 1 sein   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md3"></a>
bxCAN Master Setup / bxCAN Slave Setup</h3>
<p>Hier werden die Startup Parameter des bxCAN Master Controllers festgelegt.<br  />
 Wenn man den bxCAN Slave auch aktiviert hat wird ein identischer Abschnitt für diesen angezeigt.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Parameter  </th><th class="markdownTableHeadNone">Wert  </th><th class="markdownTableHeadNone">Beschreibung   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Initial Bitrate  </td><td class="markdownTableBodyNone">[ Zahl, Integer ]  </td><td class="markdownTableBodyNone">Hier kann eine Bitrate ausgewählt werden welche zuvor im Bereich "Baudrate Parameter" definiert wurde   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone" rowspan="4">Controller Mode  </td><td class="markdownTableBodyNone">Normal  </td><td class="markdownTableBodyNone">Standard. Der Controller nimmt ganz normal am Bus teil   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Loopback  </td><td class="markdownTableBodyNone">CAN-Tx und CAN-Rx des Controllers werden innerhalb des µC verbunden. Damit lässt sich ohne weiteren Teilnehmer ein aktives Busverhalten simulieren.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Silent  </td><td class="markdownTableBodyNone">Der Controller nimmt nicht an der Arbitrierung Teil. Damit kann man auf einem Bus mithören ohne diesen zu beeinflussen   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Silent &amp; Loopback  </td><td class="markdownTableBodyNone">Kombination aus den beiden   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Time Triggered Mode  </td><td class="markdownTableBodyNone">true / false  </td><td class="markdownTableBodyNone">Zeitstempel   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone" rowspan="3">Auto Bus off  </td><td class="markdownTableBodyNone">true  </td><td class="markdownTableBodyNone">Der CAN Controller geht nach einem Bus-Off von allein in den aktiven Zustand   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">false  </td><td class="markdownTableBodyNone">Der CAN Controller muss per Software vom Bus-Off in den aktiven Zustand gebracht werden.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">-  </td><td class="markdownTableBodyNone">Der Bus-Off Zustand kann erst verlassen werden wenn 128 mal 11 rezessive Bits empfangen wurden (Siehe CAN-Error Mangement)   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone" rowspan="2">Auto Wake up  </td><td class="markdownTableBodyNone">true  </td><td class="markdownTableBodyNone">Der CAN Controller wacht bei eingehenden NAchrichten von alleine auf   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">false  </td><td class="markdownTableBodyNone">Der CAN Controller muss per Software geweckt werden   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Auto Retransmission  </td><td class="markdownTableBodyNone">true / false  </td><td class="markdownTableBodyNone">Wählt aus ob die Nachrichten bei fehlgeschlagener Arbitrierung erneut gesendet werden sollen   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone" rowspan="2">Receive FIFO Locked  </td><td class="markdownTableBodyNone">true  </td><td class="markdownTableBodyNone">Neue Nachrichten überschreiben den vollen Rx-FIFO   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">false  </td><td class="markdownTableBodyNone">Es werden keine weiteren Nachrichten mehr angenommen, wenn der Rx-FIFO voll ist   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone" rowspan="2">time based priority on transmission  </td><td class="markdownTableBodyNone">true  </td><td class="markdownTableBodyNone">Das Senden erfolgt in der zeitlichen Reihenfolge wie die Messages dem Tx-FIFO übergeben werden   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">false  </td><td class="markdownTableBodyNone">Das Senden unterliegt den normalen Arbitrierungsregeln, es wird also entsprechend der CAN-Id der Vorrang gegeben   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">CAN Hardware filter  </td><td class="markdownTableBodyNone">[ Zahl, Integer ]  </td><td class="markdownTableBodyNone">Gibt die maximale Anzahl der genutzten Hardware Filter für diesen Controller an.<br  />
Der bxCAN Slave hat die restlichen Filter des bxCAN Masters zur Verfügung   </td></tr>
</table>
<h2><a class="anchor" id="de_subsecCanInterface"></a>
CAN Interface</h2>
<p>Ich muss hier dann noch das System mit den PDUs erklären.</p>
<div class="image">
<img src="../../T01_P20_config_canif.png" alt="" width="40%"/>
<div class="caption">
Parameter on CAN Interface</div></div>
<h3><a class="anchor" id="autotoc_md4"></a>
Parameter Settings</h3>
<p>Größe des Rx bzw des Tx Buffers.<br  />
 Im Gegensatz zu AUTOSAR habe ich die Buffer im <a class="el" href="../../d0/d88/class_can_if.html" title="the class to work on the CAN controller interface">CanIf</a> Module umgesetzt. Das bxCan Modul hat nur drei Rx Mailboxen. Das Hardware Module entspricht der STM HAL, welche ja unverändert übernommen wird.</p>
<h3><a class="anchor" id="autotoc_md5"></a>
RX/TX PDU Configuration</h3>
<p>Alle Parameter sind als Komma-Listen zu benutzten. Das heißt auch, dass in jeder Liste die gleiche Anzahl an Elementen vorhanden sein muss. Stimmt die Anzahl der Elemente eines Parameters nicht, so wird der Source Code Generator eine Fehlermeldung generieren.<br  />
 In diesem Fall sind die generierten Konfigurationsdateien nutzlos.</p>
<dl class="todo"><dt><b><a class="el" href="../../dd/da0/todo.html#_todo000001">Todo:</a></b></dt><dd>Vielleicht kennt jemand ja einen Weg diese Konfiguration in Tabellenform ähnlich der FreeRTOS Konfiguration in der STM32CubeIDE umzusetzen.</dd></dl>
<p>Ziel ist e, dass die Konfiguration hier nur für Nachrichten ohne Übertragungsprotokoll notwendig ist. Aktuell kann das CanFT2p0-Protokoll die Konfiguration schon selber durch führen.</p>
<h4><a class="anchor" id="autotoc_md6"></a>
Name list of Interface L-PDUs</h4>
<p>Liste der L-PDU Namen.<br  />
 Mit Hilfe der PDU-Namen wird der jeweilige "Kommunikationspfad" ausgewählt. So wird zum Beispiel der Funktion <code><a class="el" href="../../db/d0a/group___t_m___can_if___func.html#ga9b738780c7f103ad66c2b24cf3805134" title="Requests transmission of a PDU using the Tx software Buffer.">CanIf::Transmit()</a></code> die <a class="el" href="../../d7/d66/group___t_m___can_if_cfg.html#gad44163a8083a2ab035e8a006bbd120f1">TxPduId</a> und ein Pointer zu den zu sendenden Datenbytes übergeben.<br  />
 Die Namen werden hier in der Oberfläche immer ohne irgendwelche Prefixe oder Ergänzungen genannt. Im Code werden die Namen dann mit dem Prefix des jeweiligen Modules sowie mit Rx-/Tx-Kennung versehen. Die erzeugten Namen aller Module sind dann in der <a class="el" href="../../d8/dd3/_ecu_names___cfg_8h_source.html">EcuNames_Cfg.h</a> zu finden.</p>
<p>Wir können im Tutorial die Namen erst einmal so belassen. Ich werde bei den folgenden Punkten nur dann explizit erwähnen, das wir etwas ändern, wo es notwendig ist.</p>
<h4><a class="anchor" id="autotoc_md7"></a>
List of CAN Ids / List of CAN Id Masking</h4>
<p>Diese zwei Parameter werden zur Konfiguration der Hardware Filter genutzt.</p>
<p>Das erste Zeichen gibt an ob das Extended Id Bit (IDE) gesetzt werden soll. Aktuell wird nur geprüft ob das erste Zeichen ein 'E' oder ein 'e' ist. Ist dies nicht der Fall, dann wird von Standard CAN ausgegangen. Das Trennzeichen an zweiter Stelle ist egal. Alle Zeichen ab der dritten Stelle bis zum nächsten Komma werden unverändert in den Source Code übernommen. Es stehen also alle gängigen Formationen (hex, dec, oct, bin) zur Verfügung.</p>
<p>CanId1, CanId2 oder auch IdMask1 und IdMask2 sind keine gültigen Zahlen. Demnach müssen wir hier im Tutorial gültige CAN-Ids eingeben</p>
<h4><a class="anchor" id="autotoc_md8"></a>
List of message length</h4>
<p>Anzahl der Datenbytes</p>
<h4><a class="anchor" id="autotoc_md9"></a>
List of CAN HW Controller</h4>
<p>Der verwendete CAN Controller per Name. Aktuell werden die Namen des bxCan Modules unterstützt. Also können Master oder Slave benannt werden. Alternativ kann mit dem ersten Buchstaben, also 'M' oder 'S' abgekürzt werden.<br  />
 Die FDCAN Controller der neueren STM32 werden durchnummeriert. Ich werde aber auch Master als CAN1 und Slave als CAN2 akzeptieren.</p>
<p>Wir nutzen im Tutorial nur den Master des bxCAN. Also müssen wir aus dem Slave auch einen Master (oder Kurzform "M") machen.</p>
<h4><a class="anchor" id="autotoc_md10"></a>
List of assigned N-PDU</h4>
<p>Hier wird der Name des übergelagerten PDU benannt. Diese Namen sollten durch die Konfiguration des jeweiligen Protokollmodules entstehen</p>
<p>Im Tutorial nutzen wir keine höheren Layer. Da diese Namen trotzdem vom Compiler gesucht werden, müssen diese Dummynamen bleiben.</p>
<h4><a class="anchor" id="autotoc_md11"></a>
List the assigned upper layer</h4>
<p>Verwendetes Transport Layer (siehe auch <a class="el" href="../../d3/d89/group___t_m___osi_layer3_lower_interface.html#ga9e9562e3c64dea55d05e8e8e9af08180">CanIf_UpperLayerType</a>). Das <a class="el" href="../../d0/d88/class_can_if.html" title="the class to work on the CAN controller interface">CanIf</a> muss wissen an welches Protokollmodul eine empfangene Nachricht weiter gereicht werden muss, bzw wohin ein erfolgreiches Versenden zurück gemeldet werden muss.<br  />
 AUTOSAR nutzt hierzu die Kombination aus "übergeordneten Layer" und "PDU-Id". Mit C++ läst sich das auch einfach in Funktionspointeraufrufen realisieren. Es wird also die Zukunft zeigen, wie weit wir das hier nutzen.</p>
<p>Damit das <a class="el" href="../../d0/d88/class_can_if.html" title="the class to work on the CAN controller interface">CanIf</a> nicht versucht das IsoTP-Protokoll anzusprechen, müssen wir das <code>CanTP</code> zweimal zu <code>undef</code> ändern.</p>
<p>Nach der Änderung der Parameter sollte die Konfiguration so aussehen </p><div class="image">
<img src="../../T01_P21_change_parameter.png" alt="" width="40%"/>
<div class="caption">
Change parameter CAN Interface</div></div>
<h6></h6>
<h1><a class="anchor" id="secFirstCodeGen"></a>
Den Code für das CanIf Modul generieren</h1>
<p>Jetzt noch das Modul für die DemoApplication aktivieren und wir können den Code Generator starten. <img src="../../T01_P22_file_generation.png" alt="" width="30%" class="inline" title="Start Code Generator"/></p>
<p>Wenn man jetzt im Projekt Browser mal in die vielen neuen Verzeichnisse hinein schaut, wird man neue Dateien entdecken. </p><div class="image">
<img src="../../T01_P23_file_generation_done.png" alt="" width="80%"/>
<div class="caption">
All generated files</div></div>
<p>Alles was sich im Verzeichnis mit dem Application Namen befindet, sind generierte Dateien. Im Unterverzeichnis "Target" werden die eigentlichen Konfigurationen erzeugt. Das Verzeichnis "App" beinhaltet die eigentliche Application.<br  />
 Die generierten Dateien verhalten sich sich genauso wie wir es in der <code>main.c</code> kennen gelernt haben. Es werden also nur Änderungen innerhalb der "User Code Blöcke" über eine Code Generation hinweg beibehalten.<br  />
 Schaut man zum Beispiel einmal in die <a class="el" href="../../d8/dd3/_ecu_names___cfg_8h_source.html">EcuNames_Cfg.h</a> so findet man ziemlich am Anfang (die Kommentare sind für die Doku geändert) </p><pre class="fragment">/ * USER CODE BEGIN EcuNames_Cfg__h 0 * /

/ ** @brief this enum shows the naming conventions of used PDU names * /
typedef enum
{
  N_PDU_Dummy_for_Test,
  L_PDU_Dummy_for_Test,
  CanUndefUl_Rx_Target1,
  CanUndefUl_Rx_Target2,
  CanUndefUl_Tx_Target1,
  CanUndefUl_Tx_Target2
}CanUL_PDU_for_Test;

/ * USER CODE END EcuNames_Cfg__h 0 * /
</pre><p>Man kann dieses enum also frei bearbeiten. Hier sind auch unsere Rx und Tx PDU Namen Target1 und Target2 als Dummy angelegt.</p>
<p>Im Verzeichnis "Drivers/BSP" gibt es jetzt ein Verzeichnis "TM_Engineering_board". Darin sind die kopierten Dateien aus dem Board Support Package. Diese Dateien werden bei jeder Code Generation neu hier her kopiert. Änderungen da drin können also nur zu Versuchszwecken durch geführt werden und sind nicht angedacht.</p>
<p>In der oben geöffneten <code>main()</code> kann man auch erkennen das eine <code>MX_CanIf_AppDemo_Init()</code> und eine <code>MX_CanIf_AppDemo_Process()</code> Funktion aufgerufen wird. Beide Funktionen sind in der <code>CanIf_AppDemo.cpp</code> implementiert. Wir können also abseits der eigentlichen <code>main()</code> mit C++ objektorientiert weiter arbeiten.</p>
<h1><a class="anchor" id="de_HALvsPACK"></a>
Das ExpansionPack übernimmt Aufgaben aus der HAL</h1>
<p>Also wollen wir mal ausprobieren ob sich die "CanIf_AppDemo" bauen lässt. </p><div class="image">
<img src="../../T01_P24_multiple_definition.png" alt="" width="80%"/>
<div class="caption">
Linker error multiple definition of `HAL_CAN_MspInit'</div></div>
<p> Wir erinnern uns daran, dass in der Information des ExpansionPack etwas stand, dass wir das Generieren der HAL-Funktionen deaktivieren müssen. Und genau das ist der Grund für diesen Linker Fehler.</p>
<h2><a class="anchor" id="autotoc_md12"></a>
Diese Punkte muss ich noch ins Tutorial aufnehmen</h2>
<ul>
<li>ich muss noch an das blaue LED denken</li>
<li>Build führt zu Fehler multiple definition of &lsquo;HAL_CAN_MspInit&rsquo;</li>
<li>Deaktivierung des Code Generators für das STM-CAN-Modul</li>
<li>Was ist mit den Interupt Callbacks</li>
</ul>
<h1><a class="anchor" id="de_secRestartIDE"></a>
Was ist bei einem "normalen" Öffnen der IDE anders als beim ersten Start</h1>
<p>Die "*.ioc" wird nicht automatisch geöffnet </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d4/de9/examples.html">Beispiele / Projekte / Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.16 </li>
  </ul>
</div>
</body>
</html>
